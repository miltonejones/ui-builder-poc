<?xml version="1.0" encoding="UTF-8"?><record_update table="sp_widget">
    <sp_widget action="INSERT_OR_UPDATE">
        <category>custom</category>
        <client_script><![CDATA[/**
 * client.js - experimental state machine application
 *
 * State machine diagram
 * https://stately.ai/registry/editor/d8012c3d-6b85-4f71-bdbd-fa581ffb522b?machineId=501be2b1-f4f7-415c-9b00-24eb11607544
 *
 * Purpose:
 * Defines the AngularJS controller and state machine for the query builder UI.
 * Handles all UI interaction and state management.
 *
 * Sections:
 *
 * 1. Controller definition
 *    - Binds to $scope
 *    - Controller state variables
 *    - Interactive functions
 *
 * 2. State machine creation
 *    - Actions
 *    - Guards
 *    - Services
 *    - Initialization
 *
 * 3. Helper functions
 *    - Invoke resource
 *    - Find column definitions
 *    - Format predicates
 *    - Misc utilities
 *
 * 4. State machine framework
 *    - Handles transitions
 *    - Calls actions and services
 *    - Binds state to $scope
 *
 * Usage:
 * - Import and add api.controller to Angular module dependencies
 * - Connect UI elements to controller functions
 * - State machine manages interaction and state
 */

api.controller = function ($scope) {
  /* widget controller */
  var c = this;

  var COOKIE_NAME = "selected-column-settings";

  $scope.pageSizes = [10, 25, 50];
  $scope.nullTypes = ["is empty", "is not empty", "is anything"];

  // initialize first tab
  $scope.queryTabs = [createTab()];
  $scope.queryTabIndex = 0;
  $scope.handleKeypress = function (event, inputValue) {
    if (event.which === 13) {
      // check if the key pressed is Enter key
      c.send({
        // send ad hoc query message to the machine
        type: "ad hoc",
        field: inputValue,
      });
    }
  };

  // generated state machine automatically binds to the current tab
  generateStateMachine(function (tabMachine) {
    // start the machine for the first tab
    tabMachine.send("begin");
  });

  // load any column settings from local storage
  loadRememberedColumnSettings();

  // Using 'c' functions send messages to the state machine workflow from the UI
  // ---------------------------------------------------------------------------------/

  /**
   * Adds a new tab to the queryTabs array.
   * If a table name is provided, checks if a tab with the same table name already exists.
   * If a tab with the same table name exists, sets the current tab to that tab.
   * Otherwise, creates a new tab and appends it to the queryTabs array.
   * Sets the queryTabIndex to the index of the new tab.
   * Generates a state machine and binds it to the current tab.
   * If a table name is provided, sends an 'auto' event to the state machine with the table name.
   * Otherwise, sends a 'begin' event to the state machine.
   * @param {string} table - The name of the table to check for existing tabs.
   */
  c.addTab = function (table) {
    var index = $scope.queryTabs.length;

    if (table) {
      var existingNames = $scope.queryTabs.map(function (tab) {
        return tab.machine.context.selectedTable.name;
      });

      var existingTabIndex = existingNames.indexOf(table);
      if (existingTabIndex > -1) {
        return c.setTab(existingTabIndex);
      }
    }

    // create and append new tab
    $scope.queryTabs.push(createTab());
    $scope.queryTabIndex = index;

    // generated state machine automatically binds to the current tab
    generateStateMachine(function (tabMachine) {
      if (table) {
        return tabMachine.send({
          type: "auto",
          table: table,
        });
      }
      tabMachine.send("begin");
    });
  };

  /**
   * Sets the active tab and updates the state machine accordingly.
   * @param {number} index - The index of the tab to set as active.
   */
  c.setTab = function (index) {
    // Set the active tab index
    $scope.queryTabIndex = index;

    // Get the state machine from the selected tab
    $scope.machine = $scope.queryTabs[index].machine;

    // Update the machine state
    $scope.machineState = $scope.machine.state;
  };

  c.navigateRecord = function (index) { 
		if (index === 0) {
			return c.send('cancel')
		}
		
		var node = $scope.machine.context.recordCrumbs[index];
		
		 
		if (node.table) {
			return c.send({
				type: 'open',
				id: node.label,
				name: node.table,
				index: index
			});
		}
		
		c.addTab(node.label);
		
  };

  c.openRecord = function (row, col) { 
		// info click event for current record
		if (!col && !!row._row_data && !!row._row_data.sysId) { 
			return c.send({
				type: "open",
				id: row._row_data.sysId,
				name: $scope.machine.context.selectedTable.name,
			});
		} 
		// event for referenced record
		c.send({
			type: 'open',
			id: row[col].value,
			name: row[col].table
		});
		
		/*
    var column = $scope.machine.context.columnMap[col];
    if (!column.reference) {
      return;
    }

    c.send({
      type: "open",
      id: row[col],
      name: column.reference,
    }); */
  };

  c.announce = function (col) {
    c.send({
      type: "choose",
      column: col,
    });
  };

  c.expand = function (col) {
    c.send({
      type: "expand",
      column: col,
    });
  };

  c.resize = function (n) {
    c.send({
      type: "run",
      size: n,
    });
  };

  c.selectAll = function () {
    c.send({
      type: "choose",
      column: true,
    });
  };

  // executes table search request
  c.search = function (param) {
    invokeResource(
      "getTables",
      function (response) {
        c.send({
          type: "update",
          value: response.data.message,
        });
      },
      {
        filter: "sys_nameLIKE" + param,
      }
    );
  };

  c.setPredicate = function (pred) {
    c.send({
      type: "set",
      predicate: pred,
    });
  };

  /**
   * Adds a new predicate to the list of predicates.
   * @param {string} type - The type of the predicate.
   */
  c.addPredicate = function (type) {
    c.send({
      type: "add",
      predicateType: type,
    });
  };

  /**
   * Removes a predicate from the predicates array at the specified index.
   * @param {number} index - The index of the predicate to remove.
   */
  c.dropPredicate = function (index) {
    c.send({
      type: "drop",
      index: index,
    });
  };

  return;

  // ---------------------------------------------------------------------------------/

  /**
   * ACTIONS/SERVICES/GUARDS
   *  - Actions modify machine.context values
   *  - Services invoke methods on external actors
   *  - Guards control conditional transitions
   */

  function createActions() {
    /**
     * Filters the predicates in the given context based on the event field.
     * Adds a new predicate to the filtered predicates array.
     * Returns the updated predicates array and the pageNum set to 1.
     *
     * @param {Object} context - The context object containing the predicates and selectedFilters.
     * @param {Object} event - The event object containing the field.
     * @returns {Object} - The updated predicates array and the pageNum set to 1.
     */
    function adhocQuery(context, event) {
      // Filter the predicates array based on the event field
      var filteredPredicates = context.predicates.filter(function (predicate) {
        return !!predicate.field && predicate.field !== event.field;
      });

      // Get the selected filter value for the event field
      var selectedFilter = context.selectedFilters[event.field];

      // If the selected filter value is not a string, return
      if (typeof selectedFilter !== "string") {
        return;
      }

      // Determine the type of the new predicate based on the filtered predicates array
      var type = !!filteredPredicates.length ? "and" : "";

      // Create a new predicate object
      var newPredicate = {
        type: type,
        field: event.field,
        operator: getPredicateOperator(selectedFilter),
        value: selectedFilter.replace(/\*/g, ""),
      };

      // Set the predicate operator types
      setPredicateOperatorTypes(context, newPredicate);

      // Add the new predicate to the filtered predicates array
      filteredPredicates.push(newPredicate);

      // Return the updated predicates array and the pageNum set to 1
      return {
        predicates: filteredPredicates,
        pageNum: 1,
      };
    }

    /**
     * Removes a predicate from the context's predicates array.
     * @param {Object} context - The context object.
     * @param {Object} event - The event object.
     * @param {number} event.index - The index of the predicate to remove.
     * @returns {Object} - The updated context object with the predicate removed.
     */
    function dropPredicate(context, event) {
      // Copy the predicates array from the context object
      var predicates = context.predicates.slice();

      // Remove the predicate at the specified index
      predicates.splice(event.index, 1);

      // Return the updated context object
      return {
        predicates: predicates,
      };
    }

    /**
     * Appends a new predicate to the context's predicates array.
     * @param {Object} context - The context object.
     * @param {Object} event - The event object.
     * @returns {Object} - The updated context object.
     */
    function appendPredicate(context, event) {
      // Get the predicates array from the context object
      var predicates = context.predicates;

      // Push a new predicate object to the predicates array
      predicates.push({
        field: null,
        operator: null,
        value: null,
        type: event.predicateType,
      });

      // Return the updated context object
      return {
        predicates: predicates,
      };
    }

    function setPredicateOperatorTypes(context, predicate) {
      var item = findColumn(context, predicate.field);

      $scope.filterTypes.choice = $scope.filterTypes.string;

      // Get the predicate options for the item's type
      var predOpts = $scope.filterTypes[item.type];

      // If predicate options are not found, return
      if (!predOpts) {
        alert('Invalid field type "' + item.type + '"');
      }

      // Set the predicate options for the predicate
      predicate.predOpts = predOpts;
      predicate.choices = item.choices;
    }

    function assignPredicate(context, event) {
      var pred = event.predicate;

      setPredicateOperatorTypes(context, pred);

      var updatedPredicates = context.predicates.map(function (existing) {
        if (existing.field === pred.field) {
          return pred;
        }
        return existing;
      });
      return {
        predicates: updatedPredicates,
      };
    }

    function changePredicate(context) {
      // Map over the predicates array
      var lines = context.predicates.map(function (pred) {
        // Check if field is not defined
        if (!pred.field) return alert("Predicate has no field!");

        // Find the item in columnList that matches the field
        var item = findColumn(context, pred.field);

        // Check if operator is not defined
        if (!pred.operator) return; // alert("No operator was found");

        // Get the predicate options based on the item type
        var predOpts =
          $scope.filterTypes[item.type] || $scope.filterTypes.string;

        // Check if predicate options are not defined
        if (!predOpts)
          return alert('No filterTypes for item "' + item.type + '"');

        // Get the code for the operator
        var code = predOpts[pred.operator];

        // Get the operator based on the predicate type
        var op = !pred.type ? null : pred.type === "or" ? "^OR" : "^";

        context.selectedFilters[pred.field] = formatPredicate(pred);

        // Filter out any falsy values and join the array elements
        return [op, pred.field, code, pred.value].filter(Boolean).join("");
      });

      // Update the lines variable in the scope
      return {
        queryLines: lines,
        filter: lines.join(""),
      };
    }

    /**
     * Updates the fields and tableColumns based on the selectedColumns in the context.
     * @param {Object} context - The context object containing the selectedColumns.
     * @returns {Object} - An object containing the updated fields and tableColumns.
     */
    function updateFields(context) {
      // Get the keys of the selectedColumns object
      var keys = Object.keys(context.selectedColumns);

      // Filter the keys to only include the ones with truthy values
      var filteredKeys = keys.filter(function (key) {
        return !!context.selectedColumns[key];
      }); 
			
      return {
        fields: filteredKeys, 
      };
    }
		
		function updateTableColumns(context) {
			
      // Map the filtered keys to their corresponding values in the selectedColumns object
      var tableColumns = context.fields.filter(function (key) {
          return context.selectedColumns[key];
        });

      return {  
        tableColumns: tableColumns,
      };
		}

    /**
     * Assigns page number, page size, sort direction, and sort key based on the given context and event.
     * @param {Object} context - The current context.
     * @param {Object} event - The event object containing page, size, and sort information.
     * @returns {Object} - An object containing the assigned page number, page size, sort direction, and sort key.
     */
    function assignPageNum(context, event) {
      // Assign page number, default to 1 if not provided
      var pageNum = event.page || 1;

      // Assign page size, default to context.pageSize if not provided
      var pageSize = event.size || context.pageSize;

      // Assign sort direction, default to context.sortDir if not provided
      var sortDir = !event.sort
        ? context.sortDir
        : context.sortDir === "ASC"
        ? "DESC"
        : "ASC";

      // Assign sort key, default to context.sortKey if not provided
      var sortKey = event.sort || context.sortKey;

      // Return an object containing the assigned values
      return {
        pageNum: pageNum,
        pageSize: pageSize,
        sortDir: sortDir,
        sortKey: sortKey,
      };
    }

    /**
     * Toggles whether a table column is selected.
     * @param {Object} context - The current context object.
     * @param {Object} event - The event object containing the column to toggle.
     * @returns {Object} - The updated context object.
     */
    function toggleColumn(context, event) {
      var selectedColumns = context.selectedColumns;

      // If the column is a boolean, show all columns
      if (typeof event.column === "boolean") {
        // Set all columns to true in selectedColumns
        context.columns.forEach(function (col) {
          selectedColumns[col.name] = true;
        });

        // HACK: since I didn't want to make a special event for this
        // call the updateFields action manually from here
       // var updatedContext = updateFields(context);
       // updatedContext.selectedColumns = selectedColumns;
        persistColumns(context.selectedTable.name, selectedColumns);
        return {
          selectedColumns: selectedColumns,
        };
      } else {
        // Toggle the visibility of the column
        selectedColumns[event.column] = !selectedColumns[event.column];
        persistColumns(context.selectedTable.name, selectedColumns);
        return {
          selectedColumns: selectedColumns,
        };
      }
    }

    function persistColumns(label, selectedColumns) {
      var memory = JSON.parse(localStorage.getItem(COOKIE_NAME) || "{}");
		
      memory[label] = JSON.stringify(selectedColumns);
      localStorage.setItem(COOKIE_NAME, JSON.stringify(memory));
    }

    function arrangeColumns(context, event) {
      var array = context.tableColumns;
      var itemIndex = event.index;
      var newIndex = itemIndex + event.offset;
      if (newIndex < 0 || newIndex >= array.length) {
        return alert('Invalid index' + itemIndex);
      }
      var newArray = array.slice();
      var removedItem = newArray.splice(itemIndex, 1)[0];
      newArray.splice(newIndex, 0, removedItem);
		//	alert (JSON.stringify(newArray))
      return { tableColumns: newArray };
    }

    /**
     * Assigns columns to the context object based on the event value.
     * @param {Object} context - The current context object.
     * @param {Object} event - The event object containing the columns value.
     * @returns {Object} - The updated context object.
     */
    function assignColumns(context, event) {
      // Extract the columns value from the event object
      var columns = event.value;

      // Update the columns and create a column map and column keys
      var columnMap = updateColumns(columns);
      var columnKeys = Object.keys(columnMap);

      // Create a fresh context object with the updated columns, column map, and column keys
      var freshContext = {
        columns: columns,
        columnMap: columnMap,
        columnKeys: columnKeys,
        selectedColumns: {},
        predicates: [
          {
            field: null,
            operator: null,
            value: null,
          },
        ],
				sourceIsSettings: false
      };

      // Retrieve the selected columns from local storage
      var memoryColumns = JSON.parse(
        localStorage.getItem(COOKIE_NAME) || "{}"
      );
      var selectedColumns = memoryColumns[context.selectedTable.name];

      // If selected columns exist, update the fresh context object with the selected columns and fields
      if (selectedColumns) {
        freshContext.selectedColumns = JSON.parse(selectedColumns);
        var updatedContext = updateFields(freshContext);
        freshContext.fields = updatedContext.fields;
      }

      // Return the updated context object
      return freshContext;
    }
		
		/**
		 * Assigns a record ID and updates the record crumbs based on the given context and event.
		 * @param {Object} context - The current context.
		 * @param {Object} event - The event object.
		 * @returns {Object} - An object containing the assigned record ID, reference table name, and updated record crumbs.
		 */
		function assignRecordId(context, event) {
			// Get the record crumbs from the context or initialize an empty array
			var crumbs = context.recordCrumbs || [];

			if (event.child) {
				// If the event has a child, add the child's label and ID to the record crumbs
				crumbs.push({
					label: event.name
				}, {
					label: event.id,
					table: event.name
				});
			} else if (event.index) {
				// If the event has an index, update the record crumbs by slicing the array up to the index
				crumbs = crumbs.slice(0, event.index + 1);
			} else {
				// If the event has neither a child nor an index
				crumbs = [
					{
						label: context.selectedTable.label
					},
					// If the selected table name is different from the event name, add the event name to the record crumbs
					context.selectedTable.name === event.name ? null : {
						label: event.name
					},
					{
						label: event.id,
						table: event.name
					}
				].filter(Boolean);
			}

			return {
				sysId: event.id,
				refTableName: event.name,
				recordCrumbs: crumbs
			};
		}
		
		
    return {
      dropPredicate: dropPredicate,
      appendPredicate: appendPredicate,
      assignPredicate: assignPredicate,
      changePredicate: changePredicate,
      adhocQuery: adhocQuery,
      assignPageNum: assignPageNum,
      arrangeColumns: arrangeColumns,
      assignColumns: assignColumns,
      updateFields: updateFields,
      toggleColumn: toggleColumn,
			updateTableColumns: updateTableColumns, 
      assignRecordId: assignRecordId,

      assignReferenceColumns: function (_, event) {
        var referenceColumns = event.value;
        var referenceKeys = referenceColumns.reduce(function (out, col) {
          out[col.name] = col;
          return out;
        }, {});
        return {
          referenceColumns: event.value,
          referenceKeys: referenceKeys,
        };
      },

      assignColumnSrc: function (_, event) {
        return {
          sourceIsSettings: true,
        };
      },
      assignRecord: function (_, event) {
        return {
          record: event.value[0],
        };
      },

      clearColumns: function () {
        return {
          tableColumns: null,
        };
      },

      assignIssue: function (_, event) {
        return {
          error: event.value,
        };
      },

      assignSort: function (_, event) {
        return {
          sortKey: event.field,
        };
      },

      assignTableList: function (_, event) {
        return {
          tableList: event.value,
        };
      },

      assignTableLabel: function (context, event) {
        return {
          selectedTable: {
            label: event.value,
            name: context.refTableName,
          },
          filter: null,
        };
      },

      assignTableName: function (_, event) {
        return {
          refTableName: event.table,
        };
      },

      assignTable: function (_, event) {
        return {
          selectedTable: event.table,
          filter: null,
        };
      },

      assignRows: function (context, event) {
        var rows = event.value.rows;
        var recordCount = event.value.count;

        return {
          rows: rows,
          recordCount: recordCount,
        };
      },

      updatePages: function (context, event) {
        // Get the ticket list from the context

        // Get the page number from the event, default to 1 if not provided
        var pageNum = context.pageNum || 1;

        // Calculate the total number of pages based on the page size
        var pageCount = Math.ceil(context.recordCount / context.pageSize);

        // Calculate the starting index of the visible tickets based on the page number and page size
        var startNum = (pageNum - 1) * context.pageSize;

        return {
          currentPage: pageNum,
          pages: getPages(pageNum, pageCount),
        };
      },

      expandColumn: function (context, event) {
        var expandedColumns = context.expandedColumns;
        expandedColumns[event.column] = !expandedColumns[event.column];
        return {
          expandedColumns: expandedColumns,
        };
      },

      clearTable: function () {
        return {
          selectedColumns: {},
          expandedColumns: {},
          dataTable: null,
          selectedTable: {},
          recordCount: 0,
          rows: null,
        };
      },
    };
  }

	
  function createGuards() {
    return {
			"source was ready state": function (context) {
				return !context.sourceIsSettings;
			},
      "no saved column list": function (context) {
				// Retrieve the selected columns from local storage
				var memoryColumns = JSON.parse(
					localStorage.getItem(COOKIE_NAME) || "{}"
				);
				var selectedColumns = memoryColumns[context.selectedTable.name]; 
        return !selectedColumns;
      },
    };
  }

	
  function createServices() {
    return {
      identifyTable: function (context) {
        invokeResource("identifyTable", onComplete, {
          table: context.refTableName,
        });
      },

      describeReference: function (context) {
        invokeResource("getTable", onComplete, {
          table: context.refTableName,
        });
      },

      saveReference: function (context) {
        var writableProps = Object.keys(context.record)
          .filter(function (key) {
            return context.referenceKeys[key].writable;
          })
          .reduce(function (out, key) {
            out[key] = context.record[key];
            return out;
          }, {});

        invokeResource("setRecord", onComplete, {
          table: context.refTableName,
          sysId: context.sysId,
          fields: writableProps,
        });
      },

      openReference: function (context) {
        var fields = context.referenceColumns.map(function (col) {
          return col.name;
        });

        invokeResource("getRecord", onComplete, {
          table: context.refTableName,
          sysId: context.sysId,
          fields: fields,
        });
      },

      describeTable: function (context) {
        invokeResource("getTable", onComplete, {
          table: context.selectedTable.name,
        });
      },

      executeQuery: function (context) {
        invokeResource("readTable", onComplete, {
          table: context.selectedTable.name,
          fields: context.fields,
          size: context.pageSize,
          page: context.pageNum,
          filter: context.filter,
          sortKey: context.sortKey,
          sortDir: context.sortDir === "ASC" ? "DESC" : "ASC",
        });
      },
    };
  }

  // HELPERS
  // ---------------------------------------------------------------------------------/

  /**
   * Loads remembered column settings from local storage
   */
  function loadRememberedColumnSettings() {
    // Get the selectedColumns from local storage and parse it as JSON
    var memory = JSON.parse(localStorage.getItem(COOKIE_NAME) || "{}");

    // Get the keys of the memory object
    var keys = Object.keys(memory);

    // If there are keys in the memory object
    if (keys.length) {
      // Create a filter string by mapping each key to 'name=key' and joining them with '^OR'
      var filter = keys
			   .reverse()
			   .slice(0,5)
        .map(function (key) {
          return "name=" + key;
        })
        .join("^OR");

      // Invoke the 'getTables' resource with the filter and a callback function
      invokeResource(
        "getTables",
        function (res) {
          // Set the $scope.memory to the response data message
          $scope.memory = res.data.message;
        },
        {
          filter: filter,
        }
      );
    }
  }

  function generateStateMachine(callback) {
    // get all the needed JSON objects from the database
    invokeResource("loadJson", function (response) {
      $scope.filterTypes = response.data.message.filter_types;

      // assign state machine definition to scope
      $scope.machine = response.data.message.query_builder_state_machine;

      // set machineState to the state machine initial state
      $scope.machineState = $scope.machine.initial;

      // assign this machine to the currently open tab
      $scope.queryTabs[$scope.queryTabIndex].machine = $scope.machine;

      // create State Machine workflow using the JSON definition
      var workflow = createMachine({
        actions: createActions(),
        guards: createGuards(),
        services: createServices(),
        controller: c,
        $scope: $scope,
      });

      if (callback) {
        callback(workflow);
      }
    });
  }

  function updateColumns(columns) {
    // Reduce the columns array to create a column map
    return columns.reduce(function (out, col) {
      out[col.name] = col;
      if (col.children) {
        col.children.forEach(function (kid) {
          // kid.reference = col.reference;
          out[col.name + "." + kid.name] = kid;
        });
      }
      return out;
    }, {});
  }

  /**
   * Function to handle completion of an API response.
   * @param {Object} response - The API response object.
   */
  function onComplete(response) {
    // Check if the response has data and a message property
    if (response.data && response.data.message) {
      // Send a message with the data loaded event type and the message value
      return c.send({
        type: "data loaded",
        value: response.data.message,
      });
    }
    if (response.data && response.data.error) {
      // Send a message with the data loaded event type and the message value
      return c.send({
        type: "data error",
        value: response.data.error,
      });
    }
  }

  /**
   * Returns an array of page numbers based on the current page and total number of pages.
   * @param {number} currentPage - The current page number.
   * @param {number} totalPages - The total number of pages.
   * @returns {array} - An array of page numbers.
   */
  function getPages(currentPage, totalPages) {
    var pages = [];
    var startPage = Math.max(currentPage - 5, 1);
    var endPage = Math.min(startPage + 9, totalPages);

    // Loop through the range of page numbers and push them to the 'pages' array
    for (var i = startPage; i <= endPage; i++) {
      pages.push(i);
    }

    return pages;
  }

  /**
   * Invokes a resource action with the given action name and options.
   * Calls the callback function with the response from the server.
   * @param {string} action - The name of the action to invoke.
   * @param {function} callback - The callback function to call with the server response.
   * @param {object} options - The options to pass to the action.
   */
  function invokeResource(action, callback, options) {
    var payload = { actionName: action };

    // If options are provided, add them to the payload object
    if (options) {
      Object.keys(options).forEach(function (key) {
        payload[key] = options[key];
      });
    }

    // Execute the function with the refreshed data
    // this will send a 'data loaded' message to the
    // state machine with the data response
    c.server.update().then(function () {
      c.server.get(payload).then(callback);
    });
  }

  /**
   * Finds a column in the $scope.columns array based on the given field.
   * @param {string} field - The field to search for in the columns array.
   * @returns {object} - The found column object, or undefined if not found.
   */
  function findColumn(context, field) {
    // Check if the field does not contain a dot (.)
    if (field.indexOf(".") < 0) {
      // Find the column with the matching name in the $scope.columns array
      return context.columns.find(function (column) {
        return column.name === field;
      });
    }

    // Split the field by dot (.) to get the parent and child names
    var parts = field.split(".");

    // Find the parent column with the matching name in the $scope.columns array
    var parentColumn = context.columns.find(function (column) {
      return column.name === parts[0];
    });

    // Find the child column with the matching name in the parent column's children array
    var childColumn = parentColumn.children.find(function (column) {
      return column.name === parts[1];
    });

    return childColumn;
  }

  function createTab() {
    return {
      title: "Untitled Query-1",
      machine: {},
      app: {},
    };
  }

  /**
   * Formats a predicate based on its operator.
   * @param {Object} pred - The predicate object.
   * @param {string} pred.operator - The operator of the predicate.
   * @param {string} pred.value - The value of the predicate.
   * @returns {string} - The formatted predicate.
   */
  function formatPredicate(pred) {
    switch (pred.operator) {
      case "starts with":
        return pred.value + "*";
      case "ends with":
        return "*" + pred.value;
      case "contains":
        return "*" + pred.value + "*";
      default:
        return pred.value;
    }
  }

  function getPredicateOperator(str) {
    if (str.startsWith("*") && str.endsWith("*")) {
      return "contains";
    } else if (str.startsWith("*")) {
      return "ends with";
    } else if (str.endsWith("*")) {
      return "starts with";
    } else {
      return "is";
    }
  }

  /**
	  DO NOT MODIFY BELOW THIS LINE
	  State machine framework
	*/
  function createMachine(t){var n,e=t.actions,a=t.guards,r=t.services,c=t.controller;function o(t,e){var r=$scope.machine;Array.isArray(t)?i(t.find(function(t){var e=a[t.cond],c=!!e&&Boolean(e(r.context,n));return!t.cond||c}),e):i(t,e)}function i(t,a){var c=$scope.machine,i="object"==typeof n?n:{},u=f(i,{data:a}),h={context:c.context};function v(t){if(Array.isArray(t))t.forEach(function(t){var n=(0,e[t.type])(h.context,u);h.context=f(h.context,n)}),s(h.context);else{var n=(0,e[t.type])(h.context,u);h.context=f(h.context,n),s(h.context)}}c.states[c.state].exit&&v(c.states[c.state].exit),Boolean(t.target)&&($scope.machineState=t.target,c.state=t.target,localStorage.setItem("machine-state",t.target)),t.actions&&v(t.actions);var m=c.states[t.target];m&&(m.entry&&v(m.entry),m.invoke&&function t(e,a){var c=r[e.src];if(c)try{var i=c(a,n);if(e.onDone)return o(e.onDone,i)}catch(s){if(e.onError)return o(e.onError,s)}}(m.invoke,h.context),m.always&&o(m.always))}function s(t){var n=$scope.machine,e=f(n.context,t);n.context=e,$scope.machine=n}function f(t,n){for(var e in n)t[e]=n[e];return t}return c.matches=function(t){return Array.isArray(t)?t.some(function(t){return $scope.machineState===t}):$scope.machineState===t},c.can=function(t){var n=$scope.machine.states[$scope.machineState];if(n.on)return Boolean(n.on[t])},c.send=function(t){var e=t.type||t;$scope.machine.state=$scope.machineState,function t(e,a){var r=$scope.machine,c=r.states[$scope.machineState];if(n=a,c){var i=c.on[e]||r.on[e];i&&o(i)}}(e,t)},c}
};
]]></client_script>
        <controller_as>c</controller_as>
        <css>.record-grid,
.column-grid {
  margin: 1rem 0;
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr 1fr;
  grid-template-rows: auto;
  gap: 0.25rem;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.record-grid {
  grid-template-columns: 1fr 1fr 1fr 1fr;
  gap: 1rem;
}

.column-grid div {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.column-grid div.active {
  color: blue;
}

.nav-link.active {
  font-weight: 600;
  color: blue;
}

.num {
  text-align: right;
}

.ref {
  text-decoration: underline;
  cursor: pointer;
  color: #2a6496;
}

td.active {
  color: blue;
}

.column-panel {
  position: absolute;
  top: -120vh;
  left: 0;

  width: 50%;
  margin: 0 25%;

  height: 480px;

  background-color: white;
  border: 1px solid #ccc;
  padding: 1rem;
  border-radius: 1rem;
  transition: all 0.55s linear;
  overflow: auto;
  box-shadow: 0px 2px 4px -1px rgba(0, 0, 0, 0.2),
    0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12);
}

.column-panel.open {
  top: 20vh;
}

.column-kid {
  margin-left: 2rem;
}

.busy {
  opacity: 0.4;
}

.spacer {
  flex-grow: 1;
}

.modal-header {
  display: flex;
  align-items: center;
}

th,
td {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 280px;
  color: #222;
}

ul.selector {
  height: 400px;
  overflow: auto;
}

ul.selector,
ul.row {
  list-style: none;
}

ul.selector li.indent {
  margin-left: 2rem;
}

ul.row li {
  padding: 0 1rem;
}

ul.row li.active {
  color: blue;
}

.tab-container {
  border-bottom: solid 1px #d0d0d0;
  flex-grow: 1;
}

.flexible {
  display: flex;
  align-items: center;
  gap: 1rem;
}

.flexible.center {
  justify-content: center;
}

.predicate {
  display: grid;
  grid-template-columns: 40px 1fr 1fr 1fr 100px;
  grid-template-rows: auto;
  gap: 1rem;
  padding: 1rem;
}

.input-group {
  display: table;
  border-collapse: separate;
}

.input-group-addon,
.form-control {
  display: table-cell;
  margin-bottom: 0;
}

.input-group-addon {
  width: 1%;
  white-space: nowrap;
  vertical-align: middle;
  background-color: #fff;
  border: 1px solid #ccc;
  border-radius: 0 4px 4px 0;
  padding: 6px 12px;
  font-size: 14px;
  font-weight: normal;
  line-height: 1;
  text-align: center;
}

.input-group .form-control {
  border-radius: 4px 0 0 4px;
  border-right: 0;
  border-color: #ccc;
}

/* Add focus state */
.form-control:focus {
  border-color: #66afe9;
  outline: 0;
  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075),
    0 0 8px rgba(102, 175, 233, 0.6);
  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075),
    0 0 8px rgba(102, 175, 233, 0.6);
}

.query-wrapper {
  position: relative;
  height: 100vh;
  /*outline: dotted 1px gray;*/
}

.drawer-panel {
  position: fixed;
  left: 0;
  opacity: 0.4;
  top: 100%;
  bottom: -100px;
  width: 80vw;
  margin: 0 10vw;
  background-color: #fff;
  border: 1px solid #ccc;
  padding: 1rem;
  border-radius: 1rem;
  transition: all 0.5s ease-in;
  min-height: 400px;
  overflow: auto;
  box-shadow: 0px 2px 4px -1px rgba(0, 0, 0, 0.2),
    0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12);
}

.drawer-panel.loading {
  opacity: 1;
  top: 80%;
  bottom: 100px;
}

.drawer-panel.ready {
  opacity: 1;
  top: 40px;
  max-height: calc(100vh - 80px);
}

.badge {
  font-weight: 400;
  background-color: #f5f5f5;
  color: #222;
}

.badge.active {
  font-weight: 600;
  color: #222;
  background-color: #fff;
  border: solid 1px #222;
}

.badge.badge-primary {
  color: #fff;
  background-color: #007bff;
}

.badge.active.badge-primary {
  color: #007bff;
  background-color: #fff;
  border: solid 1px #007bff;
}

.glyphinfo .glyphicon-info-sign {
  opacity: 0;
  transition: opacity 0.3s ease-in;
}
.glyphinfo .glyphicon-info-sign:hover {
  opacity: 1;
}
</css>
        <data_table>sp_instance</data_table>
        <demo_data/>
        <description/>
        <docs/>
        <field_list/>
        <has_preview>true</has_preview>
        <id>query_builder</id>
        <internal>false</internal>
        <link><![CDATA[function link(scope, element, attrs, controller) {  }]]></link>
        <name>Query Builder</name>
        <option_schema/>
        <public>false</public>
        <roles/>
        <script><![CDATA[(function() {
  /* populate the 'data' object */
  /* e.g., data.table = $sp.getValue('table'); */
//sys_db_object
	
	
	function getTables() {
		var resource = createResource('sys_db_object', ['sys_name','label','name', 'create_access', 'read_access', 'delete_access', 'update_access'])
		data.message = resource.execute(input.filter)
	}
	
	function getRecord() {
		var resource = createResource(input.table, input.fields); 
		data.message = resource.execute('sys_id=' + input.sysId);   
	}
	
	function setRecord() {
		var resource = createResource(input.table); 
		try {
		  data.message = resource.update(input.sysId, input.fields);
		} catch (ex) {
			data.error = ex.message;
		}
	}
	
	function getTable() {
		var resource = createResource(input.table); 
		data.message = resource.describe()
	}
	
	function identifyTable() { 
		var resource = createResource('sys_db_object', ['label']); 
		var records = resource.execute('name=' + input.table);
		data.message = records[0].label
	}
	
	function readTable() { 
		var resource = createResource(input.table, input.fields); 
		var rows = resource.execute(input.filter, input.page, input.size, input.sortKey, input.sortDir)
		var count = resource.count(input.filter);
		
		data.message =  {
			rows: rows,
			count: count
		}
	}
	
	function loadJson() {
			// Create a resource object with the specified table and fields
			var resource = createResource("x_ebh_ccde_application_json", [
				"title",
				"content",
			]);

    // Execute the resource with the application filter
    var response = resource.execute('title=filter_types^ORtitle=query_builder_state_machine'); 
		 
    var object = {};
    // Iterate over the response rows and parse the content as JSON
    response.forEach(function (row) {
      object[row.title] = JSON.parse(row.content);
    });

    // Return the object containing the JSON data
    data.message = object;

	}
	
	
	
  var requestMethods = { 
		getTables: getTables,
		getTable: getTable,
		getRecord: getRecord,
		readTable: readTable,
		setRecord: setRecord,
		identifyTable: identifyTable,
		loadJson: loadJson
  };

  // execute the requested method if there is one
  if (input) {
    var actionName = input.actionName;
    var requestMethod = requestMethods[actionName];
    if (requestMethod) {
      return requestMethod();
    }
  }

	
	
	
	
	return;
	
	 /**
   * Creates a resource object with insert and execute methods
   * @param {string} table - The name of the table to interact with
   * @param {Array} fields - The fields to include in the resource object
   * @returns {Object} - The resource object
   */
  function createResource(table, fields) {
    return {
      fields: fields,

      /**
       * Inserts a new record into the table
       * @param {Array} fields - The fields to insert
       * @returns {string} - The sys_id of the inserted record
       */
      insert: function (fields) {
        var gr = new GlideRecord(table);

        fields.forEach(function (item) {
          gr[item.alias || item.field] = item.value;
        });

        // Insert the new record into the table
        return gr.insert();
      },

      update: function (sysId, fields) {
        var gr = new GlideRecord(table); 
				gr.get(sysId);
        Object.keys(fields).forEach(function (item) {
				  gr.setValue(item, fields[item]); 
        }); 
				return gr.update(); 
      },

      /**
       * Retrieves the columns of a GlideRecord table.
       * @returns {Array} - An array of objects containing field, label, and type properties.
       */
      describe: function () {
        var t = new GlideRecord(table); 
				t.setLimit(1)
				t.query();
				t.next()
				var fields = t.getElements(); //or getFields if global scope
				var fieldList = [];

				 
				for (var i = 0; i < fields.length; i++) {
					var glideElement = fields[i]; //or field.get(i) if global scope
					var descriptor = glideElement.getED();

					var fldName = glideElement.getName().toString();
					var fldLabel = descriptor.getLabel().toString();
					var fldType = descriptor.getInternalType().toString();
					var canWrite = glideElement.canWrite();
          var ref = glideElement.getRefRecord();
          var choices = glideElement.getChoices()
					 
						
					var reference = null, children = null, fullName = fldName; 
					if (ref) {
						reference = glideElement.getReferenceTable() ;  
						if (reference !== table) {
							var resource = createResource(reference);
							children = resource.describe();
							fullName = reference + '.' + fldName; 
						}
					} 

					fieldList.push({
						name: fldName,
						type: fldType,
						label: fldLabel,
						writable: canWrite,
						choices: glideElement.getChoices(),
						reference: reference === table ? null : reference,
						children: children,
						fullName: fullName
					}); 
				}

				return fieldList.sort(function(a,b) {
					return a.name > b.name ? 1 : -1;
				}); 
      },

      count: function (conditions) {
        var gr = new GlideRecord(table);
        if (conditions) {
          gr.addEncodedQuery(conditions);
        }
        gr.query();
        return gr.getRowCount();
      },

      /**
       * Executes a query on the table and returns the matching records
       * @param {Array} conditions - The conditions to apply to the query
       * @returns {Array} - The matching records
       */
      execute: function (conditions, page, size, sortby, sortdir) {
        var gr = new GlideRecord(table);
				var pageSize = size || 10;

        if (conditions) {
          gr.addEncodedQuery(conditions);
        }
				
				if (sortdir && sortby) {
					if (sortdir === 'DESC') {
            gr.orderByDesc(sortby);
					} else {
            gr.orderBy(sortby); 
					}
				} else {
          gr.orderByDesc("sys_created_on"); 
				}
				
        var num = page || 1;
        var start = pageSize * (num - 1);
        var end = start + pageSize;
 
        gr.chooseWindow(start, end);
        gr.query();

        var records = [];

        // Iterate through each record in the GlideRecord
        while (gr.next()) {
					
          var record = {
						_row_data: {
							sysId: gr.getValue('sys_id')
						}
					}; 
					
          this.fields.forEach(function (field) {
            if (field.indexOf(".") > 0) {
              // handle reference fields
              var both = field.split(".");
              var ref = gr[both[0]].getRefRecord();
              if (ref.isValidRecord()) {
                record[field] = ref.getValue(both[1]);
              }
              return;
            }
						
						
				
						var glideElement = gr.getElement(field); 
						var reference = glideElement.getRefRecord(); 
						if (reference) {
              record[field] = {
								label: gr.getDisplayValue(field),
								value: gr.getValue(field),
								table: glideElement.getReferenceTable(),
							}; 
						} else {
              record[field] = gr.getValue(field);
						}
          });
          records.push(record);
        }

        return records;
      },
    };
  }
	
	
})();]]></script>
        <servicenow>false</servicenow>
        <sys_class_name>sp_widget</sys_class_name>
        <sys_created_by>Milton.Jones@employbridge.com</sys_created_by>
        <sys_created_on>2023-11-29 18:16:51</sys_created_on>
        <sys_id>222bdd7947363110265ad698436d431b</sys_id>
        <sys_mod_count>995</sys_mod_count>
        <sys_name>Query Builder</sys_name>
        <sys_package display_value="Voluntary Deductions" source="x_ebh_voluntary_0">591c37a24729a110265ad698436d431e</sys_package>
        <sys_policy/>
        <sys_scope display_value="Voluntary Deductions">591c37a24729a110265ad698436d431e</sys_scope>
        <sys_update_name>sp_widget_222bdd7947363110265ad698436d431b</sys_update_name>
        <sys_updated_by>Milton.Jones@employbridge.com</sys_updated_by>
        <sys_updated_on>2023-12-06 13:00:53</sys_updated_on>
        <template><![CDATA[<div class="query-wrapper">
  <nav aria-label="breadcrumb">
    <ol class="breadcrumb">
      <li class="breadcrumb-item"><a href="#">ACoE Table Browser!</a></li>
      <li class="breadcrumb-item" ng-if="!!machine.context.rows">
        <span ng-if="!machine.context.queryLines.length" href="#"
          >{{machine.context.selectedTable.label}}</span
        >
        <a ng-if="!!machine.context.queryLines.length" href="#"
          >{{machine.context.selectedTable.label}}</a
        >
      </li>
      <li
        class="breadcrumb-item"
        ng-repeat="line in machine.context.queryLines"
      >
        <a ng-if="!$last" href="#">{{line}}</a>
        <span ng-if="$last">{{line}}</span>
      </li>
    </ol>
  </nav>

  <!-- application header -->
  <div class="flexible">
    <h3 class="flexible">
      <i class="glyphicon glyphicon-tasks"></i>
      ACoE Table Browser
    </h3>

    <div class="tab-container">
      <ul class="nav nav-tabs">
        <li class="nav-item" ng-repeat="tab in queryTabs">
          <a
            class="nav-link"
            href="#"
            ng-class="{'active': $index === queryTabIndex}"
          >
            <span ng-click="c.setTab($index)"
              >{{tab.machine.context.selectedTable.label || tab.title}}</span
            >
            <span aria-hidden="true">&times;</span></a
          >
        </li>
        <li class="nav-item" ng-click="c.addTab()">
          <a class="nav-link" href="#">
            <i class="glyphicon glyphicon-plus"></i>
          </a>
        </li>
      </ul>
    </div>
  </div>

  <!-- query result contaiker -->
  <div
    ng-if="c.matches(['wait for query results', 'viewing query results', 'editing query filter', 'edit column settings'])"
  >
    <!-- query result header -->
    <div class="flexible">
      <h3>{{machine.context.selectedTable.label}}</h3>
      <div class="badge">{{machine.context.recordCount}} records</div>

      <div style="flex-grow: 1">
        <!-- spacer -->
      </div>

      <a
        class="badge success"
        ng-click="c.resize(size)"
        ng-class="{ active: size === machine.context.pageSize }"
        ng-repeat="size in pageSizes"
      >
        {{size}}
      </a>

      per page

      <button
        class="btn btn-sm"
        ng-click="c.send('settings')" 
      >
        <i class="glyphicon glyphicon-cog" />
      </button>
      <button
        class="btn btn-sm"
        ng-click="c.send('filter')"
        data-toggle="modal"
        data-target="#exampleModal"
      >
        <i class="glyphicon glyphicon-filter" />
      </button>
    </div>

    <!-- query result grid -->
    <table class="table table-striped" ng-class="{busy: c.matches('wait for query results')}">
      <thead>
        <tr>
          <th>
          	&nbsp;
          </th>
          <th ng-repeat="column in machine.context.tableColumns">
            <a href="#" ng-click="c.send({type: 'run', sort: column})"
              >{{machine.context.columnMap[column].label}}</a
            >

            <i
              class="glyphicon"
              ng-if="column === machine.context.sortKey"
              ng-class="{'glyphicon-chevron-up': machine.context.sortDir === 'DESC',
                       'glyphicon-chevron-down': machine.context.sortDir !== 'DESC'}"
            ></i>
          </th>
        </tr>
        <tr>
          <td>
          	&nbsp;
          </td>
          <td ng-repeat="column in machine.context.tableColumns">
            <input
              ng-disabled="machine.context.columnMap[column].type === 'reference'"
              ng-model="machine.context.selectedFilters[column]"
              ng-keypress="handleKeypress($event, column)"
              class="form-control form-control-sm"
              placeholder="Filter {{machine.context.columnMap[column].label}}"
            />
          </td>
        </tr>
      </thead>
      <tbody>
        <tr ng-repeat="item in machine.context.rows">
          <td class="glyphinfo">
          	<i ng-click="c.openRecord(item)" class="glyphicon glyphicon-info-sign"></i>
          </td>
          <td
            ng-repeat="column in machine.context.tableColumns"
            ng-click="c.openRecord(item, column)"
            ng-class="{ ref: !!machine.context.columnMap[column].reference,
                        num: machine.context.columnMap[column].type === 'integer' || machine.context.columnMap[column].type === 'number' }"
          >
            {{item[column].table ? item[column].label : item[column]}}
          </td>
        </tr>
      </tbody>
    </table>

    <!-- query result pagination -->
    <div
      ng-if="machine.context.recordCount > machine.context.pageSize"
      class="flexible center"
    >
      <nav>
        <ul class="pagination">
          <li class="page-item">
            <a class="page-link" href="#" aria-label="Previous">
              <span aria-hidden="true">&laquo;</span>
            </a>
          </li>
          <li
            class="page-item"
            ng-class="{'active': n === machine.context.pageNum}"
            ng-repeat="n in machine.context.pages"
            ng-click="c.send({type: 'run', page: n})"
          >
            <a class="page-link" href="#">{{ n }}</a>
          </li>
          <li class="page-item">
            <a class="page-link" href="#" aria-label="Next">
              <span aria-hidden="true">&raquo;</span>
            </a>
          </li>
        </ul>
      </nav>
    </div>
  </div>

  <!-- table name search input -->
  <div class="form-group" ng-show="c.can('update')">
    <label>Table name</label>
    <div>
      <small class="form-text text-muted">Select a table to view</small>
    </div>

    <div class="input-group">
      <input
        ng-model="machine.context.dataTable"
        ng-change="c.search(machine.context.dataTable)"
        class="form-control form-control-sm"
        placeholder="Find a table..."
      />
      <span class="input-group-addon">
        <i class="glyphicon glyphicon-search"></i>
      </span>
    </div>

    <div ng-if="memory" class="flexible">
      Recent tables
      <small
        ng-click="c.send({type: 'next', table: item})"
        href="#"
        ng-repeat="item in memory"
        class="badge"
      >
        {{item.label}}
      </small>
    </div>
  </div>

  <!-- table name search results -->
  <div
    class="list-group"
    ng-if="!!machine.context.dataTable && !machine.context.selectedTable.name"
  >
    <a
      ng-click="c.send({type: 'next', table: item})"
      href="#"
      class="list-group-item list-group-item-action"
      ng-repeat="item in machine.context.tableList"
    >
      <b>{{item.label}}</b>
      <div>{{item.name}}</div>
      <div class="flexible">
        <small>Permissions:</small>
        <div ng-repeat="access in ['create', 'update', 'read', 'delete']"
             class="badge" ng-class="{active: '1' === item[access + '_access'].toString()}">
          {{access}} 
        </div>  
       </div>
    </a>
  </div>

  <!-- control buttons -->
  <div ng-if="!!machine.context.selectedTable.name" class="flexible">
    <div class="spacer">
      <!-- spacer -->
    </div>
    <button class="btn btn-sm" ng-click="c.send('cancel')">Cancel</button>
    <button
      class="btn btn-sm btn-primary"
      ng-if="c.can('save')"
      ng-click="c.send('save')"
    >
      Save Record
    </button>
    <button
      class="btn btn-sm btn-primary"
      ng-disabled="!machine.context.fields.length || !c.can('run')"
      ng-click="c.send('run')"
    >
      Run Query
    </button>
  </div>

  <div class="column-panel" ng-class="{open: c.matches('edit column settings')}">
  
    <div class="flexible">
      <div class="spacer">
        <!-- spacer -->
      </div>
      <button class="btn btn-sm" ng-click="c.send('cancel')">&times;</button> 
    </div>

    Set the order for colums from
    <b>{{machine.context.selectedTable.label}}</b> .
    <a ng-if="c.can('choose again')" ng-click="c.send('choose again')" href="#"
      >Select columns.</a
    >

    <ul class="list-group">
      <li
        class="list-group-item"
        ng-repeat="key in machine.context.tableColumns"
        style="display: flex; gap: 1rem"
      >
        <div>
          <div>{{ machine.context.columnMap[key].label}}</div>
          <small> {{key}} </small>
        </div>
        <div style="flex-grow: 1">
          <!-- spacer -->
        </div>
        <i
           ng-if="c.can('arrange')"
          ng-click="c.send({type: 'arrange', index: $index, offset: -1})"
          class="glyphicon glyphicon-chevron-up"
        ></i>
        <i
          ng-click="c.send({type: 'arrange', index: $index, offset: 1})"
          class="glyphicon glyphicon-chevron-down"
        ></i>
      </li>
    </ul>
  </div>

  <!-- column selector panel -->
  <div class="column-panel open" ng-if="c.matches('select columns')">

    Select colums from <b>{{machine.context.selectedTable.label}}</b> to return
    in your query. <a ng-click="c.selectAll()" href="#">Select all</a>.

    <table class="table">
      <thead>
        <tr>
          <th>Label</th>
          <th>Name</th>
          <th>Type</th>
        </tr>
      </thead>
      <tbody>
        <tr ng-repeat="item in machine.context.columns">
          <td>
            <i
              class="glyphicon glyphicon-chevron-right"
              ng-class="{'glyphicon-chevron-down': !!machine.context.expandedColumns[item.name]}"
              ng-click="c.expand(item.name)"
              ng-if="!!item.children"
            ></i>

            <input
              class="form-check-input"
              type="checkbox"
              ng-click="c.announce(item.name)"
              ng-checked="!!machine.context.selectedColumns[item.name]"
            />

            <a
              ng-click="c.announce(item.name)"
              ng-class="{active: !!machine.context.selectedColumns[item.name]}"
              href="#"
              >{{item.label}}</a
            >

            <div ng-if="!machine.context.expandedColumns[item.name]">
              <div
                class="column-kid"
                ng-click="c.announce(item.name + '.' + kid.name)"
                ng-if="!!machine.context.selectedColumns[item.name + '.' + kid.name]"
                ng-repeat="kid in item.children"
              >
                <input class="form-check-input" type="checkbox" checked />
                {{item.name}}.{{kid.name}}
              </div>
            </div>

            <ul
              class="row"
              ng-if="!!machine.context.expandedColumns[item.name]"
            >
              <li
                ng-class="{active: !!machine.context.selectedColumns[item.name + '.' + kid.name]}"
                ng-repeat="kid in item.children"
                ng-click="c.announce(item.name + '.' + kid.name)"
              >
                <b> {{kid.label}} </b>

                <div>{{kid.name}}</div>
              </li>
            </ul>
          </td>
          <td ng-class="{active: !!machine.context.selectedColumns[item.name]}">
            {{item.name}}
          </td>
          <td ng-class="{active: !!machine.context.selectedColumns[item.name]}">
            {{item.type}}
          </td>
        </tr>
      </tbody>
    </table>
    
    
    <div class="flexible" ng-if="!!machine.context.selectedTable.name">
      <div class="spacer">
        <!-- spacer -->
      </div>
      <button class="btn btn-sm" ng-click="c.send('cancel')">Cancel</button>

      <button
        class="btn btn-sm btn-primary"
        ng-disabled="!machine.context.fields.length || !c.can('run')"
        ng-click="c.send('run')"
      >
        Run Query
      </button>
    </div>

  </div>

  <!-- filter modal -->
  <div
    class="modal fade"
    id="exampleModal"
    tabindex="-1"
    role="dialog"
    aria-labelledby="exampleModalLabel"
    aria-hidden="true"
  >
    <div class="modal-dialog modal-lg" role="document">
      <div class="modal-content">
        <div class="modal-header">
          <h4 class="modal-title" id="exampleModalLabel">Set Filter</h4>
          <div class="spacer">
            <!-- spacer -->
          </div>
          <button
            ng-click="c.send('cancel')"
            type="button"
            class="close"
            data-dismiss="modal"
            aria-label="Close"
          >
            <span aria-hidden="true">&times;</span>
          </button>
        </div>
        <div class="modal-body">
          <div>
            Build a filter by adding conditions that contain a field, operator,
            and value(s).
          </div>

          <div class="predicate" ng-repeat="pred in machine.context.predicates">
            <i ng-if="!pred.type" />
            <div ng-if="!!pred.type"><b>{{pred.type}}</b></div>

            <!-- field picker -->
            <select
              class="form-control"
              ng-change="c.setPredicate(pred)"
              ng-model="pred.field"
            >
              <option
                ng-value="column"
                ng-repeat="column in machine.context.fields"
              >
                {{machine.context.columnMap[column].label}}
              </option>
            </select>

            <!-- operator picker -->
            <select
              class="form-control"
              ng-disabled="!pred.predOpts"
              ng-model="pred.operator"
              ng-change="c.send('change')"
              ng-options="key as key for (key, value) in pred.predOpts"
            ></select>

            <!-- value entry -->
            <div>
              <input
                ng-disabled="!!nullTypes.includes(pred.operator) || !pred.predOpts"
                ng-model="pred.value"
                ng-change="c.send('change')"
                placeholder="Enter value"
                class="form-control"
                type="search"
                list="datalist{{pred.field}}"
                id="{{pred.field}}DataList"
              />

              <datalist id="datalist{{pred.field}}">
                <option
                  ng-repeat="choice in pred.choices"
                  value="{{choice}}"
                ></option>
              </datalist>
            </div>

            <div class="flexible">
              <button
                ng-click="c.addPredicate('or')"
                class="btn btn-sm btn-primary"
              >
                or
              </button>
              <button
                ng-click="c.addPredicate('and')"
                class="btn btn-sm btn-primary"
              >
                and
              </button>
              <i
                ng-click="c.dropPredicate($index)"
                class="glyphicon glyphicon-trash"
              />
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button
            ng-click="c.send('cancel')"
            type="button"
            class="btn btn-secondary"
            data-dismiss="modal"
          >
            Close
          </button>
          <button
            ng-click="c.send('run')"
            type="button"
            data-dismiss="modal"
            class="btn btn-primary"
          >
            Apply filters
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- record viewer modal -->
  <div
    class="drawer-panel"
    ng-class="{ loading: c.matches(['wait for reference data', 'wait for record']), 
                   ready: c.matches('viewing record') }"
  >
    <div class="flexible">
     <!-- <div
        class="badge badge-primary"
        ng-click="c.addTab(machine.context.refTableName)"
      >
        Open table "{{machine.context.refTableName}}"
        <i class="glyphicon glyphicon-new-window"></i>
      </div> -->

      <div class="spacer">
        <!-- spacer -->
      </div>

      <a href="#" ng-click="c.send('cancel')">
        Close
        <i class="glyphicon glyphicon-remove"></i
      ></a>
    </div>
    
    
    <nav aria-label="breadcrumb">
      <ol class="breadcrumb">
        <li class="breadcrumb-item" ng-click="c.navigateRecord($index)" ng-repeat="crumb in machine.context.recordCrumbs"
            ><a ng-if="!$last" href="#">{{crumb.label}}</a>
          <span ng-if="$last">{{crumb.label}}</span> 
        </li> 
      </ol>
    </nav>

    

    <h3>Record Viewer</h3>

    <div class="record-grid">
      <div ng-if="!!machine.context.referenceKeys[key].label" ng-repeat="(key, value) in machine.context.record">
        <div>{{machine.context.referenceKeys[key].label}}</div>
        <div>
          <small
            ><i>{{machine.context.referenceKeys[key].type}}</i>
            {{machine.context.referenceKeys[key].name}}</small
          >
        </div>
        
        
        <div class="input-group" ng-if="!!value.table && !machine.context.referenceKeys[key].choices.length">
          <input
            class="form-control"
            ng-disabled="!machine.context.referenceKeys[key].writable" 
            ng-value="machine.context.record[key].label"
          />
          <span class="input-group-addon">
            <i class="glyphicon"
               ng-class="{'glyphicon-question-sign': !value.label, 'glyphicon-new-window': !!value.label}"
               ng-click="c.send({type: 'open', child: true, id: machine.context.record[key].value, name: machine.context.record[key].table})"
               ></i>
          </span>
        </div>


        <input ng-if="!value.table && !machine.context.referenceKeys[key].choices.length"
          class="form-control"
          ng-disabled="!machine.context.referenceKeys[key].writable"
          type="{{machine.context.referenceKeys[key].type === 'glide_date' ? 'date' : 'text' }}"
          ng-value="machine.context.record[key]"
        /> 
        
        
        <select ng-if="!!machine.context.referenceKeys[key].choices.length"
          class="form-control"
          ng-disabled="!machine.context.referenceKeys[key].writable" 
          ng-model="machine.context.record[key]"
        >
          <option>--None--</option>
          <option ng-repeat="choice in machine.context.referenceKeys[key].choices" ng-value="choice">{{choice}}</option>
        </select>
        
        
      </div>
    </div>
  </div>

  <div class="progress" ng-if="c.can('data loaded')">
    <div
      class="progress-bar progress-bar-striped progress-bar-animated"
      role="progressbar"
      aria-valuenow="75"
      aria-valuemin="0"
      aria-valuemax="100"
      style="width: 100%"
    ></div>
  </div>
<div ng-if="showMachines">
  
  <hr />

  <h4>State Machines</h4>
  Tab: {{queryTabIndex}}
  <table class="table">
    <tr>
      <th>#</th>
      <th>table</th>
      <th>state</th>
      <th>columns</th>
      <th>context</th>
    </tr>
    <tr ng-repeat="tab in queryTabs">
      <td>{{$index}}</td>
      <td>{{tab.machine.context.selectedTable.label || 'Untitled Query'}}</td>
      <td>{{tab.machine.state}}</td>
      <td>{{tab.machine.context.tableColumns}}</td>
      <td>{{tab.machine.context}}</td>
    </tr>
  </table>
  </div>
</div>
]]></template>
    </sp_widget>
</record_update>
