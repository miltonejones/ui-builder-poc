<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_ux_client_script">
    <sys_ux_client_script action="INSERT_OR_UPDATE">
        <controller_preset/>
        <includes/>
        <macroponent display_value="Default">5996a635c3a2791011971d4ce00131a9</macroponent>
        <name>Send Message</name>
        <preset/>
        <required_translations>[
    
]</required_translations>
        <script><![CDATA[/** 
 * Handles an event in the state machine. 
 */
function handleEvent({ api, helpers }) {  
  
  // Destructure the machineMessage and machineState from the api.state object
  const { machineMessage, machineState, machine } = api.state;
 
  const message = typeof machineMessage === 'string' 
    ? machineMessage 
    : machineMessage.type;

  // create a new state machine and extract its 'send' method
  const { send } = createMachine({
     api,
     helpers,

     // additional data passed with the message
     payload: machineMessage,
     machine:  {

       // machine JSON from context
       ...machine,
       
       // current machine state
       state: machineState,

       // machine methods
       actions: createActions(),
       services: createServices(),
       guards: createGuards()
     },   
  });

  // send the message to the state machine
  send(message);  

  return;
 
  /**
   * ACTIONS/GUARDS/SERVICES
   */

  /**
   * Creates actions for updating deductions and records.
   * @returns {Object} - An object containing the actions.
   */
  function createActions() {
    return {
  
      /**
       * Updates a deduction in the context object based on the given event.
       * @param {Object} context - The context object containing deductions.
       * @param {Object} event - The event object containing the index, field, and previous value.
       * @returns {Object} - The updated context object with the deductions.
       */
      updateDeduction: (context, event) => {
        // Destructure deductions from the context object
        const { deductions } = context;

        // Destructure index, field, and previous value from the event object
        const { index, field, value  } = event;

        // Check if the field is 'deduction_value'
        if (field === 'deduction_value') {
          // Convert the previous value to a number and round it to 2 decimal places 
          // Update the deduction value in the deductions array
          deductions[index][field] = Number(value).toFixed(2);
        } else {
          // If the field is not 'deduction_value', use the previous value as is
          deductions[index][field] = value;
        }

        // Return the updated context object with the deductions
        return { deductions };
      },

      assignPreviewPref: (_, event) => ({
        previewOnSave: event.value
      }),

      assignLatestId: (_, event) => ({
        latestId: event.data
      }),

      /**
       * Validates deductions in a given context and event.
       * @param {Object} context - The context object.
       * @param {Object} event - The event object.
       * @returns {Object} - An object containing the validity of deductions.
       */
      validateDeductions: (context, event) => {
        // Function to check if a deduction is incomplete
        const isIncomplete = (ded) => !(Boolean(ded.deduction_type) && Number(ded.deduction_value) > 0);

        // Get the deductions from the context
        const { deductions } = context;

        // Check if any deductions are not valid
        const deductionsNotValid = deductions.some((f) =>
          Boolean(f.validation.deduction_value.length) ||
          Boolean(f.validation.deduction_type.length) ||
          isIncomplete(f)
        );

        // Return the validity of deductions
        return { deductionsNotValid };
      }, 

      /**
       * Validates a deduction value or deduction type.
       * @param {Object} context - The context object containing deductions.
       * @param {Object} event - The event object containing index, field, and value.
       * @returns {Object} - The updated deductions object with validation.
       */
      validateDeduction: (context, event) => {
        const { deductions } = context;
        const { index, field, value } = event;

        // Create an empty validation object
        const validation = {
          deduction_value: [],
          deduction_type: []
        };

        // Check if the field is deduction_value and the value is not a number or not greater than 0
        if (field === 'deduction_value' && isNaN(value)) {
          // Add an exception message to the deduction_value validation array
          validation.deduction_value = exception("Deduction Value must be a number.");
        } else if (field === 'deduction_value' && !(Number(value) > 0)) {
          // Add an exception message to the deduction_value validation array
          validation.deduction_value = exception("Deduction Value must be greater than zero.");
        } else if (field === 'deduction_type' && !Boolean(value)) {
          // Add an exception message to the deduction_type validation array
          validation.deduction_type = exception("Select a Deduction Type.");
        }

        // Update the validation property of the deduction at the specified index
        deductions[index].validation = validation;

        // Return the updated deductions object
        return { deductions };
      }, 

      /**
       * Cleans up the context by setting the values to null or -1.
       */
      cleanUp: () => {
        return {
          sys_id: -1, 
          deductions: [
            {
              deduction_type: null,
              deduction_value: null,
              validation: null
            }
          ],
          record: { }
        };
      },
 
      /**
       * Appends a new deduction to the deductions array.
       * @param {Object} event - The event object containing the deduction information.
       */
      appendNewDeduction: (context, event) => {
        const { deductions } = context;
        return {
          deductionsNotValid: true,
          deductions: deductions.concat({
            deduction_type: null,
            deduction_value: null,
            validation: null
          })
        } ;
      },

      /**
       * Drops a deduction from the deductions array in the machine context.
       * @param {Object} machine - The machine object.
       * @param {Function} setContext - The function to set the machine context.
       */
      dropDeduction: (context) => {
        // Destructure deductions and deletedIndex from machine context
        const { deductions, deletedIndex } = context;

        // Remove the deduction at the deletedIndex from the deductions array
        deductions.splice(deletedIndex, 1);

        // Update the machine context with the modified deductions array
        return { deductions };
      }, 

      assignDroppedDeduction: (_, event) => {
        return { deletedIndex: event.index };
      },
 
      /**
       * Updates the settings in the given context with the provided event.
       * @param {Object} context - The current context object.
       * @param {Object} event - The event object containing the name and value of the setting to update.
       * @returns {Object} - The updated context object with the updated settings.
       */
      applySetting: (context, event) => {
        const { settings = {} } = context;
        const updatedSettings = {
          ...settings,
          [event.name]: event.value
        };
        return {
          settings: updatedSettings
        };
      },
      
      /**
       * Updates a record with a new field value.
       * @param {Object} context - The context object containing the current record.
       * @param {Object} event - The event object containing the field and value to update.
       * @returns {Object} - The updated record object.
       */
      updateRecord: (context, event) => { 
        // Get the g_form object from the nowRecordFormBlob.gForm property of the glide_form_1 data object
        const g_form = api.data.glide_form_1.nowRecordFormBlob.gForm;

        // Destructure the record object from the context parameter, defaulting to an empty object if not provided
        const { record = {} } = context;

        // Create a new updatedRecord object by spreading the properties of the original record object and adding the new field and value
        const updatedRecord = {
          ...record,
          [event.field]: event.value,

          // added label and id to payload for talent.full_name
          label: record.label || event.label,
          id: record.id || event.id
        };

        // Set the value of the field in the g_form object to the new value
        g_form.setValue(event.field, event.value);

        // Log a message to the console indicating the field and value that was set
        console.log("%cSetting the value of '%s' to '%s'", 'border: dotted 1px magenta', event.field, event.value);

        // Return the updated record object
        return { record: updatedRecord };
      }, 
    };
  }

    
  /**
   * Creates guard functions for a specific context.
   * @returns {Object} - Object containing guard functions.
   */
  function createGuards() {
    return {
      /**
       * Checks if preview on save is enabled in the context.
       * @param {Object} context - The context object.
       * @returns {boolean} - True if preview on save is enabled, false otherwise.
       */
      'preview on save': (context) => { 
        return Boolean(context.previewOnSave);
      },
      /**
       * Checks if more input is needed based on the context and event.
       * @param {Object} context - The context object.
       * @param {Object} event - The event object.
       * @returns {boolean} - True if more input is needed, false otherwise.
       */
      'need more input': (context, event) => {
        const { record = {} } = context;
        const okay = (event.field === 'talent_user' && !!record.effective_date) || 
            (event.field === 'effective_date' && !!record.talent_user);

        return !okay;
      }
    };
  }

  /**
   * Creates a services object  
   * @returns {Object} - The services object.
   */
  function createServices() { 
    // Get the g_form object from the api.data.glide_form_1.nowRecordFormBlob.gForm property
    const g_form = api.data.glide_form_1.nowRecordFormBlob.gForm;
  
    return {
      /**
       * Saves the current record and shouts the unique value. 
       */
      saveDeduction: () => {
        // Save the record using the g_form.save() method
        g_form.save();

        // Shout and return the unique value of the record using the shout function
        shout(`Saved record ${g_form.getUniqueValue()}`);

        return g_form.getUniqueValue();
      },

      /**
       * Launches the review for the current incident. 
       */
      launchReview: () => {
        // Get the unique value of the current incident
        const sysId = g_form.getUniqueValue();

        // Navigate to the preview page with the incident sysId as a parameter
        helpers.navigate.to('preview', { sysId });
      },

      /**
       * Saves deduction types to the database. 
       */
      saveDeductionTypes: () => {
        // Get the deductions from the machine context
        const { deductions } = machine.context;

        // Get the unique system ID from the g_form object
        const incSysid = g_form.getUniqueValue();

        // Loop through each deduction
        deductions.forEach((deduction) => {
          // Create a query for the deduction and the unique system ID
          const query = createDeductionQuery(deduction, incSysid);

          // Log the query for debugging purposes
          console.log({ query });

          // Update the table with the query
          updateTable(query);
        });        
      }
    };
  }


  /**
   * HELPERS
   */


  /**
   * Creates a query string for updating/creating a record in the x_ebh_voluntary_0_deductions table.
   * @param {Object} object - Object containing fields and values to update/create record
   * @param {string} sys_id - The sys_id of the current record
   * @returns {string} - The query string for updating/creating the record
   */
  function createDeductionQuery(object, sys_id) {
    return Object.keys(object)
      .filter((item) => !!object[item]) // Filter out any fields with falsy values
      .filter((key) => ["validation"].every((word) => key !== word)) // Filter out any fields with the word "validation" in their name
      .map((key) => `${key}=${object[key]}`) // Create an array of key=value strings
      .concat(`deduction_ticket_id=${sys_id}`) // Add the sys_id to the array
      .join("^"); // Join the array with "^" to create the query string
  }

  /**
   * Updates or creates a record in the x_ebh_voluntary_0_deductions table.
   * @param {string} templateFields - The query string for updating/creating the record
   */
  function updateTable(templateFields) {
    const TABLE_NAME = "x_ebh_voluntary_0_deductions";

    // Define command object with required fields for updating/creating record
    const command = {
      table: TABLE_NAME,
      templateFields,
      useSetDisplayValue: false,
    };

    // If sys_id is not provided, create a new record
    api.data.create_record_1.execute(command);
  }

  /**
   * Emits a notification with the given content.
   * @param {string} content - The content of the notification.
   */
  function shout(content) {
    api.emit('NOW_UXF_PAGE#ADD_NOTIFICATIONS', {
      items: [
        {
          id: 'alert1',
          status: 'positive',
          icon: 'check-circle-outline',
          content,
          action: { type: 'acknowledge' }
        }
      ]
    });
  }

  /**
   * Creates an exception object with critical status, content, and icon.
   * @param {string} content - The content of the exception.
   * @returns {Array} - An array containing the exception object.
   */
  function exception(content) {
    return [{ status: "critical", content: content, icon: "circle-exclamation-fill" }];
  }


  /**
   * state machine framework
   * DO NOT MODIFY BELOW THIS LINE
   */
  function createMachine({machine:t,payload:e,api:n}){let{actions:c,guards:o,services:a}=t;function i(n,c){if(Array.isArray(n)){let a=n.find(n=>{let c=o[n.cond],a=!!c&&Boolean(c(t.context,e));return!n.cond||a});s(a,c)}else s(n,c)}function s(o,s){let l={..."object"==typeof e?e:{},data:s},f=e=>{if(Array.isArray(e)){let n={context:t.context};e.forEach(t=>{let e=c[t.type],o=e(n.context,l);n.context={...n.context,...o}}),r(n.context)}else{let o=c[e.type],a=o(t.context,l);r(a)}};t.states[t.state].exit&&f(t.states[t.state].exit),Boolean(o.target)&&n.setState("machineState",o.target),o.actions&&f(o.actions);let x=t.states[o.target];x&&(x.entry&&f(x.entry),x.invoke&&function t(n){let{src:c,onDone:o,onError:s}=n,r=a[c];if(r)try{let l=r(e);o&&i(o,l)}catch(f){s&&i(s,f)}}(x.invoke))}function r(e){let c={...t.context,...e};n.setState("machine",{...t,context:c})}return{send:function e(n){let c=t.states[t.state];if(!c)return;let o=c.on[n]||t.on[n];o&&i(o)}}}
}]]></script>
        <script_api_version>2.0.0</script_api_version>
        <sys_class_name>sys_ux_client_script</sys_class_name>
        <sys_created_by>Milton.Jones@employbridge.com</sys_created_by>
        <sys_created_on>2023-11-17 13:33:34</sys_created_on>
        <sys_id>e296e2f1c3a2791011971d4ce0013153</sys_id>
        <sys_mod_count>413</sys_mod_count>
        <sys_name>Send Message</sys_name>
        <sys_package display_value="Voluntary Deductions" source="x_ebh_voluntary_0">591c37a24729a110265ad698436d431e</sys_package>
        <sys_policy/>
        <sys_scope display_value="Voluntary Deductions">591c37a24729a110265ad698436d431e</sys_scope>
        <sys_update_name>sys_ux_client_script_e296e2f1c3a2791011971d4ce0013153</sys_update_name>
        <sys_updated_by>Milton.Jones@employbridge.com</sys_updated_by>
        <sys_updated_on>2023-11-18 21:07:22</sys_updated_on>
        <target>macroponent</target>
        <type>default</type>
    </sys_ux_client_script>
</record_update>
